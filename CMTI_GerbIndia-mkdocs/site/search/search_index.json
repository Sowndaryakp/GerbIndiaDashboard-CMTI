{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Introduction Project overview This project involves the seamless integration of Industry 4.0 and IIoT (Industrial Internet of Things) technologies. It introduces an innovative method that utilizes IIoT-based hardware for real-time monitoring, specifically focusing on the analysis of voltage and Current Sensors. A comprehensive series of tests was carried out to thoroughly to assess the performance of the IIoT-based hardware for monitoring welding machines in real-time. The experimental setup was comprised of eight welding machines, Hall effect sensors, voltage transducers, a Delta PLC DVP-12SE, Raspberry Pi, and associated components. Various voltage levels and current readings were the independent variables considered during the experiments. Project features Real-time Monitoring : Special sensors capture live data from welding machines. Data Acquisition Module : The collected data goes to a central hub (Delta PLC DVP-12SE), ensuring stable operation. Integration with Raspberry Pi : A Raspberry Pi connects to the hub, facilitating seamless integration of various systems and protocols. Monitoring Dashboard : Fast-API creates a user- friendly dashboard, offering real-time insights into welding parameters. IOT setup flowchart The process involves acquiring data from the welding machine, transferring it to the local database, and displaying it within the software interface, as depicted in the accompanying flow chart and explanation At the field level, Hall effect sensors and voltage transducers are incorporated to capture real-time data from the welding machines. The collected data is then transmitted to the Delta PLC DVP-12E, which serves as the data acquisition module. The PLC is connected to a Rasberry Pi through an Ethernet connection. The Rasberry Pi acts as a bridge to a PostgreSQL database, acting as the central repository for all connected data. A local PC is employed as the endpoint for data access and analysis. It establishes a connection to the Rasberry Pi, allowing for the retrieval of the data from postgreSQL database. Fast-API is utilized as the framework for the monitoring dashboard, offering a platform for real-time monitoring of the welding parameters.","title":"Home"},{"location":"index.html#introduction","text":"","title":"Introduction"},{"location":"index.html#project-overview","text":"This project involves the seamless integration of Industry 4.0 and IIoT (Industrial Internet of Things) technologies. It introduces an innovative method that utilizes IIoT-based hardware for real-time monitoring, specifically focusing on the analysis of voltage and Current Sensors. A comprehensive series of tests was carried out to thoroughly to assess the performance of the IIoT-based hardware for monitoring welding machines in real-time. The experimental setup was comprised of eight welding machines, Hall effect sensors, voltage transducers, a Delta PLC DVP-12SE, Raspberry Pi, and associated components. Various voltage levels and current readings were the independent variables considered during the experiments.","title":"Project overview"},{"location":"index.html#project-features","text":"Real-time Monitoring : Special sensors capture live data from welding machines. Data Acquisition Module : The collected data goes to a central hub (Delta PLC DVP-12SE), ensuring stable operation. Integration with Raspberry Pi : A Raspberry Pi connects to the hub, facilitating seamless integration of various systems and protocols. Monitoring Dashboard : Fast-API creates a user- friendly dashboard, offering real-time insights into welding parameters.","title":"Project features"},{"location":"index.html#iot-setup-flowchart","text":"The process involves acquiring data from the welding machine, transferring it to the local database, and displaying it within the software interface, as depicted in the accompanying flow chart and explanation At the field level, Hall effect sensors and voltage transducers are incorporated to capture real-time data from the welding machines. The collected data is then transmitted to the Delta PLC DVP-12E, which serves as the data acquisition module. The PLC is connected to a Rasberry Pi through an Ethernet connection. The Rasberry Pi acts as a bridge to a PostgreSQL database, acting as the central repository for all connected data. A local PC is employed as the endpoint for data access and analysis. It establishes a connection to the Rasberry Pi, allowing for the retrieval of the data from postgreSQL database. Fast-API is utilized as the framework for the monitoring dashboard, offering a platform for real-time monitoring of the welding parameters.","title":"IOT setup flowchart"},{"location":"backend.html","text":"Introduction In this system's backend architecture, Python serves as the primary language, FastAPI facilitates API services, while PostgreSQL handles the database and its management. Prerequisites install python install pycharm or visual studio code install PostgreSQL Database For data storage and management, PostgreSQL was employed as the database system, and an Entity-Relationship Diagram (ERD) illustrating the relationships between all the tables is provided below. Tables in the Database \"Admin login\" Manages administrative login credentials. Fields: email, password, created_at. \"Element Type\" Categorizes different types of elements. Fields: type, range, standard_current, standard_voltage, element_description. \"Live_recent\" Stores real-time data including current, voltage, timestamps, and machine state. Fields: current, voltage, created_at, state, machine_state, machine_id. \"Machine\" Stores machine details such as ID, name, model, maker, capacity_in_amp, date_of_purchase. Fields: machine_id, name, model, maker, capacity_in_amp, date_of_purchase. Foreign Keys in Tables \"Live_recent\" Foreign Key: \"Live_recent_machine_id_fkey\" References: \"Machine\" table's \"machine_id\" column. \"ON_data\" Foreign Key: \"ON_data_machine_id_fkey\" References: \"Machine\" table's \"machine_id\" column. \"Production_data\" Foreign Key: \"Production_data_machine_id_fkey\" References: \"Machine\" table's \"machine_id\" column. \"graph_data\" Foreign Key: \"graph_data_machine_id_fkey\" References: \"Machine\" table's \"machine_id\" column. \"live_data\" and \"vol_cur_logs\" Foreign Keys: \"live_data_machine_id_fkey\" and \"vol_cur_logs_machine_id_fkey\" References: \"Machine\" table's \"machine_id\" column. \"operator_shift\" , \"plate\" , \"std_cur_vol\" , and \"remarks\" Tables Include foreign key constraints referencing specific columns in other tables for data integrity and consistency. Technical stack Packages to be installed The following is a comprehensive list of packages utilized and required for the backend services: annotated-types==0.5.0 anyio==3.7.1 bcrypt==4.0.1 cffi==1.15.1 click==8.1.6 colorama==0.4.6 cryptography==41.0.3 distro==1.8.0 dnspython==2.3.0 ecdsa==0.18.0 email-validator==2.0.0.post2 fastapi==0.100.1 greenlet==2.0.2 h11==0.14.0 idna==3.4 passlib==1.7.4 psycopg2==2.9.6 pyasn1==0.5.0 pycparser==2.21 pydantic==2.1.1 pydantic-settings==2.0.3 pydantic_core==2.4.0 python-dotenv==0.21.1 python-jose==3.3.0 python-multipart==0.0.6 rsa==4.9 six==1.16.0 sniffio==1.3.0 SQLAlchemy==2.0.19 starlette==0.27.0 toml==0.10.2 typing_extensions==4.7.1 uvicorn==0.22.0 Project layout main.py # The main entry point for the fastapi backend application. background_tasks.py # This handles the background tasks for live data # handling idle and production data graph_tasks.py # This consists of the logic for handling the live data # for the graph main_machine_monitoring/ \u251c\u2500\u2500 database # This python package consist of modules related to database. \u2502 \u251c\u2500\u2500 db_setup.py # This module contains the connections for the database \u2502 \u251c\u2500\u2500 orm_class.py # This module consists of the ORM module of the tables \u2502 \u251c\u2500\u2500 pydantic_schema \u2502 \u251c\u2500\u2500 request_schema.py # This python module consist of pydantic modules which are \u2502 # used for the response body. \u2502 \u2514\u2500\u2500 routers # This python package consist of all the API endpoints. FastAPI endpoints through swagger To verify the endpoints, the initial step is to execute the following command in the terminal uvicorn main:app --reload --host <ip_address> --port <port_number> After executing the command, proceed to open any web browser and enter the specified IP address and port number provided in the command followed by '/docs'. <ip_address>:<port_number>/docs FastAPI CRUD Operations Guide Import Necessary Modules from fastapi import FastAPI, HTTPException from pydantic import BaseModel from typing import List app = FastAPI() Define a Pydantic Model Create a Pydantic model to define the structure of the data. Example: class Item(BaseModel): name: str description: str = None 1. Create (POST) - Add a New Item Endpoint: POST /items/ Description: This endpoint allows you to add a new item to the collection. Example Request Body: { \"name\": \"Example Item\", \"description\": \"This is an example item.\" } Implementation: @app.post(\"/items/\", response_model=Item) async def create_item(item: Item): items_db.append(item) return item 2. Read (GET) - Retrieve a List of Items Endpoint: GET /items/ Description: This endpoint retrieves a list of all items in the collection. Implementation: @app.get(\"/items/\", response_model=List[Item]) async def read_items(): return items_db 3. Read (GET) - Retrieve a Single Item by ID Endpoint: GET /items/{item_id} Description: This endpoint retrieves a single item from the collection based on its ID. Example Request: GET /items/0 Implementation: @app.get(\"/items/{item_id}\", response_model=Item) async def read_item(item_id: int): if item_id < 0 or item_id >= len(items_db): raise HTTPException(status_code=404, detail=\"Item not found\") return items_db[item_id] 4. Update (PUT) - Update an Existing Item Endpoint: PUT /items/{item_id} Description: This endpoint allows you to update an existing item in the collection. Example Request Body: { \"name\": \"Updated Item\", \"description\": \"This item has been updated.\" } Implementation: @app.put(\"/items/{item_id}\", response_model=Item) async def update_item(item_id: int, updated_item: Item): if item_id < 0 or item_id >= len(items_db): raise HTTPException(status_code=404, detail=\"Item not found\") items_db[item_id] = updated_item return updated_item 5. Delete (DELETE) - Delete an Item Endpoint: DELETE /items/{item_id} Description: This endpoint allows you to delete an item from the collection based on its ID. Example Request: DELETE /items/1 Implementation: @app.delete(\"/items/{item_id}\", response_model=Item) async def delete_item(item_id: int): if item_id < 0 or item_id >= len(items_db): raise HTTPException(status_code=404, detail=\"Item not found\") deleted_item = items_db.pop(item_id) return deleted_item Usage of JWT tokens Upon client authentication with valid credentials, the API issues a JWT token. Now, the client uses this token in its further requests. When the token is sent back to the API, it'll verify if the token is valid then allow the access to requested data Client API | | | /login(username + password) | | ---------------------------------------> | If the credeantials valid, sends the token | {JWT Token} | | <--------------------------------------- | | /post{JWT Token} | | ---------------------------------------> | Verify if token is valid | Data | | <--------------------------------------- | Post end point for the token Authentication/login : This end point is used to login a user and give JWT token for the session. Request Body { \"username\": \"user_name\", \"password\": \"user_password\" } Response Body { \"access_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\", \"token_type\": \"bearer\" } In the response body { \"access_token\": \"JWT Token\", \"token_type\": \"type of the token\" } Usage of WebSockets In the context of live data presentation, WebSockets enable a persistent, bidirectional connection that remains open until either the server or the client decides to close it. Key Features Persistent Connection : Unlike traditional HTTP requests, WebSockets maintain an open connection throughout the session, allowing for continuous and instant data exchange. Real-time Updates : The bidirectional nature of WebSockets allows the server to push updates to connected clients instantly, ensuring that live data is presented in real-time. Efficient Communication : WebSockets minimize the overhead associated with repeatedly opening and closing connections for each data request. Once established, the connection persists, reducing latency and improving efficiency. How It Works Client Request : The client initiates the WebSocket connection by sending a request to the server. This request is typically upgraded from a standard HTTP request. Connection Establishment : Upon receiving the WebSocket request, the server establishes a persistent connection with the client. Bi-Directional Communication : Both the client and server can send messages to each other at any time during the connection. This facilitates real-time updates and interaction between the two. Continuous Data Flow : Live data that is live current and voltage values, are seamlessly transmitted over the open WebSocket connection. Connection Closure : The connection remains open until either the server or the client decides to close it. This allows for dynamic control over the duration of the live data presentation session. Closing the Connection Client-Side Closure : The client can send a close frame to the server, indicating the intention to end the connection. Server-Side Closure : Alternatively, the server can initiate the closure of the WebSocket connection, signaling to the client that the live data presentation session has concluded. Endpoint for websocket ws://localhost/live_recent_ws Location of the websocket : The main functionality involving Websockets is implemented in the 'main.py' file, refer to this file to understand the integration and usage of Websockets within the project.","title":"Backend services"},{"location":"backend.html#introduction","text":"In this system's backend architecture, Python serves as the primary language, FastAPI facilitates API services, while PostgreSQL handles the database and its management.","title":"Introduction"},{"location":"backend.html#prerequisites","text":"install python install pycharm or visual studio code install PostgreSQL","title":"Prerequisites"},{"location":"backend.html#database","text":"For data storage and management, PostgreSQL was employed as the database system, and an Entity-Relationship Diagram (ERD) illustrating the relationships between all the tables is provided below.","title":"Database"},{"location":"backend.html#tables-in-the-database","text":"\"Admin login\" Manages administrative login credentials. Fields: email, password, created_at. \"Element Type\" Categorizes different types of elements. Fields: type, range, standard_current, standard_voltage, element_description. \"Live_recent\" Stores real-time data including current, voltage, timestamps, and machine state. Fields: current, voltage, created_at, state, machine_state, machine_id. \"Machine\" Stores machine details such as ID, name, model, maker, capacity_in_amp, date_of_purchase. Fields: machine_id, name, model, maker, capacity_in_amp, date_of_purchase.","title":"Tables in the Database"},{"location":"backend.html#foreign-keys-in-tables","text":"\"Live_recent\" Foreign Key: \"Live_recent_machine_id_fkey\" References: \"Machine\" table's \"machine_id\" column. \"ON_data\" Foreign Key: \"ON_data_machine_id_fkey\" References: \"Machine\" table's \"machine_id\" column. \"Production_data\" Foreign Key: \"Production_data_machine_id_fkey\" References: \"Machine\" table's \"machine_id\" column. \"graph_data\" Foreign Key: \"graph_data_machine_id_fkey\" References: \"Machine\" table's \"machine_id\" column. \"live_data\" and \"vol_cur_logs\" Foreign Keys: \"live_data_machine_id_fkey\" and \"vol_cur_logs_machine_id_fkey\" References: \"Machine\" table's \"machine_id\" column. \"operator_shift\" , \"plate\" , \"std_cur_vol\" , and \"remarks\" Tables Include foreign key constraints referencing specific columns in other tables for data integrity and consistency.","title":"Foreign Keys in Tables"},{"location":"backend.html#technical-stack","text":"","title":"Technical stack"},{"location":"backend.html#packages-to-be-installed","text":"The following is a comprehensive list of packages utilized and required for the backend services: annotated-types==0.5.0 anyio==3.7.1 bcrypt==4.0.1 cffi==1.15.1 click==8.1.6 colorama==0.4.6 cryptography==41.0.3 distro==1.8.0 dnspython==2.3.0 ecdsa==0.18.0 email-validator==2.0.0.post2 fastapi==0.100.1 greenlet==2.0.2 h11==0.14.0 idna==3.4 passlib==1.7.4 psycopg2==2.9.6 pyasn1==0.5.0 pycparser==2.21 pydantic==2.1.1 pydantic-settings==2.0.3 pydantic_core==2.4.0 python-dotenv==0.21.1 python-jose==3.3.0 python-multipart==0.0.6 rsa==4.9 six==1.16.0 sniffio==1.3.0 SQLAlchemy==2.0.19 starlette==0.27.0 toml==0.10.2 typing_extensions==4.7.1 uvicorn==0.22.0","title":"Packages to be installed"},{"location":"backend.html#project-layout","text":"main.py # The main entry point for the fastapi backend application. background_tasks.py # This handles the background tasks for live data # handling idle and production data graph_tasks.py # This consists of the logic for handling the live data # for the graph main_machine_monitoring/ \u251c\u2500\u2500 database # This python package consist of modules related to database. \u2502 \u251c\u2500\u2500 db_setup.py # This module contains the connections for the database \u2502 \u251c\u2500\u2500 orm_class.py # This module consists of the ORM module of the tables \u2502 \u251c\u2500\u2500 pydantic_schema \u2502 \u251c\u2500\u2500 request_schema.py # This python module consist of pydantic modules which are \u2502 # used for the response body. \u2502 \u2514\u2500\u2500 routers # This python package consist of all the API endpoints.","title":"Project layout"},{"location":"backend.html#fastapi-endpoints-through-swagger","text":"To verify the endpoints, the initial step is to execute the following command in the terminal uvicorn main:app --reload --host <ip_address> --port <port_number> After executing the command, proceed to open any web browser and enter the specified IP address and port number provided in the command followed by '/docs'. <ip_address>:<port_number>/docs","title":"FastAPI endpoints through swagger"},{"location":"backend.html#fastapi-crud-operations-guide","text":"","title":"FastAPI CRUD Operations Guide"},{"location":"backend.html#import-necessary-modules","text":"from fastapi import FastAPI, HTTPException from pydantic import BaseModel from typing import List app = FastAPI()","title":"Import Necessary Modules"},{"location":"backend.html#define-a-pydantic-model","text":"Create a Pydantic model to define the structure of the data. Example: class Item(BaseModel): name: str description: str = None","title":"Define a Pydantic Model"},{"location":"backend.html#1-create-post-add-a-new-item","text":"Endpoint: POST /items/ Description: This endpoint allows you to add a new item to the collection. Example Request Body: { \"name\": \"Example Item\", \"description\": \"This is an example item.\" } Implementation: @app.post(\"/items/\", response_model=Item) async def create_item(item: Item): items_db.append(item) return item","title":"1. Create (POST) - Add a New Item"},{"location":"backend.html#2-read-get-retrieve-a-list-of-items","text":"Endpoint: GET /items/ Description: This endpoint retrieves a list of all items in the collection. Implementation: @app.get(\"/items/\", response_model=List[Item]) async def read_items(): return items_db","title":"2. Read (GET) - Retrieve a List of Items"},{"location":"backend.html#3-read-get-retrieve-a-single-item-by-id","text":"Endpoint: GET /items/{item_id} Description: This endpoint retrieves a single item from the collection based on its ID. Example Request: GET /items/0 Implementation: @app.get(\"/items/{item_id}\", response_model=Item) async def read_item(item_id: int): if item_id < 0 or item_id >= len(items_db): raise HTTPException(status_code=404, detail=\"Item not found\") return items_db[item_id]","title":"3. Read (GET) - Retrieve a Single Item by ID"},{"location":"backend.html#4-update-put-update-an-existing-item","text":"Endpoint: PUT /items/{item_id} Description: This endpoint allows you to update an existing item in the collection. Example Request Body: { \"name\": \"Updated Item\", \"description\": \"This item has been updated.\" } Implementation: @app.put(\"/items/{item_id}\", response_model=Item) async def update_item(item_id: int, updated_item: Item): if item_id < 0 or item_id >= len(items_db): raise HTTPException(status_code=404, detail=\"Item not found\") items_db[item_id] = updated_item return updated_item","title":"4. Update (PUT) - Update an Existing Item"},{"location":"backend.html#5-delete-delete-delete-an-item","text":"Endpoint: DELETE /items/{item_id} Description: This endpoint allows you to delete an item from the collection based on its ID. Example Request: DELETE /items/1 Implementation: @app.delete(\"/items/{item_id}\", response_model=Item) async def delete_item(item_id: int): if item_id < 0 or item_id >= len(items_db): raise HTTPException(status_code=404, detail=\"Item not found\") deleted_item = items_db.pop(item_id) return deleted_item","title":"5. Delete (DELETE) - Delete an Item"},{"location":"backend.html#usage-of-jwt-tokens","text":"Upon client authentication with valid credentials, the API issues a JWT token. Now, the client uses this token in its further requests. When the token is sent back to the API, it'll verify if the token is valid then allow the access to requested data Client API | | | /login(username + password) | | ---------------------------------------> | If the credeantials valid, sends the token | {JWT Token} | | <--------------------------------------- | | /post{JWT Token} | | ---------------------------------------> | Verify if token is valid | Data | | <--------------------------------------- |","title":"Usage of JWT tokens"},{"location":"backend.html#post-end-point-for-the-token","text":"Authentication/login : This end point is used to login a user and give JWT token for the session. Request Body { \"username\": \"user_name\", \"password\": \"user_password\" } Response Body { \"access_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\", \"token_type\": \"bearer\" } In the response body { \"access_token\": \"JWT Token\", \"token_type\": \"type of the token\" }","title":"Post end point for the token"},{"location":"backend.html#usage-of-websockets","text":"In the context of live data presentation, WebSockets enable a persistent, bidirectional connection that remains open until either the server or the client decides to close it.","title":"Usage of WebSockets"},{"location":"backend.html#key-features","text":"Persistent Connection : Unlike traditional HTTP requests, WebSockets maintain an open connection throughout the session, allowing for continuous and instant data exchange. Real-time Updates : The bidirectional nature of WebSockets allows the server to push updates to connected clients instantly, ensuring that live data is presented in real-time. Efficient Communication : WebSockets minimize the overhead associated with repeatedly opening and closing connections for each data request. Once established, the connection persists, reducing latency and improving efficiency.","title":"Key Features"},{"location":"backend.html#how-it-works","text":"Client Request : The client initiates the WebSocket connection by sending a request to the server. This request is typically upgraded from a standard HTTP request. Connection Establishment : Upon receiving the WebSocket request, the server establishes a persistent connection with the client. Bi-Directional Communication : Both the client and server can send messages to each other at any time during the connection. This facilitates real-time updates and interaction between the two. Continuous Data Flow : Live data that is live current and voltage values, are seamlessly transmitted over the open WebSocket connection. Connection Closure : The connection remains open until either the server or the client decides to close it. This allows for dynamic control over the duration of the live data presentation session.","title":"How It Works"},{"location":"backend.html#closing-the-connection","text":"Client-Side Closure : The client can send a close frame to the server, indicating the intention to end the connection. Server-Side Closure : Alternatively, the server can initiate the closure of the WebSocket connection, signaling to the client that the live data presentation session has concluded.","title":"Closing the Connection"},{"location":"backend.html#endpoint-for-websocket","text":"ws://localhost/live_recent_ws Location of the websocket : The main functionality involving Websockets is implemented in the 'main.py' file, refer to this file to understand the integration and usage of Websockets within the project.","title":"Endpoint for websocket"},{"location":"frontend.html","text":"Introduction Project Overview: IoT Based Data Acquisition And Machine Monitoring For Welding Machine[GerbIndia] Frontend Technologies Frontend Stack Overview The project's frontend utilizes a modern tech stack including HTML5 for markup, CSS3 for styling, Tailwind CSS for utility-first styling, JavaScript for scripting, Vue3.js as the JavaScript framework, and Axios for handling HTTP requests. Prerequisites Creating a Vue 3 Project To create a Vue 3 project, you can use the Vue CLI (Command Line Interface), which is a standard tool for Vue.js development. Follow these steps: Install Node.js and npm: Before creating a Vue project, ensure that you have Node.js and npm (Node Package Manager) installed on your machine. You can download and install them from https://nodejs.org/ . Install Vue CLI: Open a terminal or command prompt and install the Vue CLI globally by running the following command: npm install -g @vue/cli Create a New Project: Navigate to the directory where you want to create your Vue 3 project using the cd command. Run the following command to create a new Vue 3 project: vue create project-name Configure Project Settings: The Vue CLI will prompt you to pick a preset. Choose \"Default ([Vue 3] babel, eslint)\" for a project with Vue 3, Babel, and ESLint. Alternatively, you can manually select features based on your project requirements. Project Initialization: Once the project is created, navigate into the project directory: cd project-name Run the Development Server: To start the development server and see your project in action, run: npm run serve Explore and Customize: Open the project in your preferred code editor. Explore the src directory where your main application code is located. Customize the project according to your needs by modifying components, adding new features, and integrating external libraries. Adding Tailwind CSS to Vue 3 Project: To add Tailwind CSS to a Vue 3 project created with the Vue CLI, you can follow these steps: Install Tailwind CSS and its Dependencies: Open a terminal in the root of your Vue 3 project. Install Tailwind CSS, PostCSS, and Autoprefixer by running the following command: npm install -D tailwindcss postcss autoprefixer Generate Tailwind Configuration Files: Create a configuration file for Tailwind CSS by running: npx tailwindcss init -p - This will generate a tailwind.config.js file and a postcss.config.js file in your project's root directory. Configure PostCSS: Open the postcss.config.js file and ensure it includes the following plugins: module.exports = { plugins: { tailwindcss: {}, autoprefixer: {}, } } Create Styles Entry Point: Create a new file, for example, src/styles/tailwind.css to serve as your styles entry point. /* src/styles/tailwind.css */ @import 'tailwindcss/base'; @import 'tailwindcss/components'; @import 'tailwindcss/utilities'; Import Tailwind CSS in Main Styles File: Open your main styles file, usually src/assets/styles/main.css, and import the Tailwind CSS styles: /* src/assets/styles/main.css */ @import './tailwind.css'; /* Your existing styles go here */ Update Build Configuration: Open vue.config.js in the root of your project (create it if it doesn't exist) and add the following configuration: // vue.config.js module.exports = { css: { loaderOptions: { postcss: { plugins: [ require('tailwindcss'), require('autoprefixer'), ], }, }, }, } Use Tailwind CSS Classes: You can now use Tailwind CSS classes in your Vue components. For example, in your Vue component's template: <template> <div class=\"bg-blue-500 text-white p-4\"> This is a Tailwind CSS component! </div> </template> Run the Development Server: Start or restart your development server: npm run serve File Structure In Vue.js 3, the file structure is flexible and depends on the complexity and requirements of your project. However, there are common conventions that you can follow to organize your Vue.js project in a clean and maintainable way. Here's a step-by-step explanation of a typical file structure for a Vue.js 3 project: Project Root: At the root of your project, you might find configuration files like package.json , babel.config.js , and vue.config.js . src Folder: The src folder is where your main source code resides. Assets: The assets folder contains static assets like images, fonts, and stylesheets. src/ |- assets/ |- images/ |- ak400.png |- styles/ Components: The components folder is where you store your Vue components. You can organize them further based on features or functionalities. src/ |- components/ |- elementMaster.vue |- filterTable.vue |- welder.vue |- ... Views/Pages: The views or pages folder is where you store higher-level components that represent pages or views in your application. src/ |- views/ |- Home.vue |- elementMasterTable.vue |- weldertable.vue |- ... Router: If you're using Vue Router for navigation, you might have a router folder to manage your routes. src/ |- router/ |- index.js Store (State Management): If you're using Vuex for state management, you might have a store folder. src/ |- store/ |- index.js |- modules/ Plugins: The plugins folder can contain Vue plugins or third-party integrations. src/ |- plugins/ |- axios.js Commands npm run dev - Start the development server and run the Vue 3 project. npm run build - Build the Vue 3 project for production deployment. Implementation Certainly! Now, I will provide an explanation for the functionalities of each component: How to generate a component and its corresponding syntax. Creating a Basic Component: Start by creating a new .vue file, for example, MyComponent.vue . <!-- MyComponent.vue --> <template> <div> <!-- Your component's template goes here --> <h1>{{ message }}</h1> </div> </template> <script> export default { data() { return { message: 'Hello, Vue!' }; } } </script> <style scoped> /* Your component-specific styles go here */ h1 { color: blue; } </style> Vue Component Syntax Breakdown: <template>: Contains the HTML structure of the component. <script>: Contains the JavaScript code for the component. <style>: Contains the component's styles (use scoped attribute to scope styles to the component). Project Functionalities Overview for Welder Page: Live Button Functionalities: Live Button Click Event: The \"Live\" button is configured to respond to the click event using the @click directive. When the button is clicked, the \"showUserLiveCurrentPopup\" function is invoked. Function Invocation: - Build the Vue 3 project for production deployment. The \"showUserLiveCurrentPopup\" function is called with an argument ( row.itemno ). The purpose and functionality of the \"showUserLiveCurrentPopup\" function are determined by the implementation in the Vue.js component or script associated with this template. Visibility Toggle: The function sets a reactive variable ( 'isUserLiveCurrentPopupVisible' ) to 'true' , making the user live current popup visible. Graph Data Configuration: The 'machineId' parameter is assigned to the 'graphData' object, updating the machineId for graph data. HTTP GET Request: An Axios HTTP GET request is made to fetch live data for the specified 'machineId' from a given endpoint. Data Validation: Checks if there is data in the response and if the array is not empty. Data Extraction: Extracts specific values (low and high standard voltage, low and high standard current) from the response data. Graph Data Update: Updates the 'graphData' object with the extracted range values. Console Logging: Logs the low standard voltage value to the console. Error Handling: Logs an error if there is no data or the array is empty in the response. Assumption: Assumes the existence of a 'sendata' function, commented out but not implemented, to update range values. The 'sendata' function is expected to be defined elsewhere in the component. Error Logging: Logs an error if there is an issue fetching data from the server. All Stats Button Functionalities: All Stats Button Click Event: The 'All Stats' button is configured to respond to the click event using the '@click' directive. When the button is clicked, the 'showStackPopup' function is invoked. Function Invocation: The 'showStackPopup' function is called. The purpose and functionality of the 'showStackPopup' function would be determined by the implementation in the Vue.js component's script. Popup Container: If the 'isStackVisible' variable is true, display a fixed-positioned container covering the entire screen, centered both vertically and horizontally. Chart Display Section: Within the container, create a rounded and shadowed section with a white background, providing padding. Render Stack Chart Component: Inside this section, render a 'Stack' chart component with a height of 96 units, passing in 'stateChartData' as a prop. Close Button: Include a close button at the top-right corner of the container. Close Icon: The close button contains an \"X\" icon sourced from an external URL, serving as a visual representation of closing the popup. Define Props: The component defines a prop named 'chartData' with default values representing a chart's minimum timestamp and data points. Render Item Function: The component has a function named 'renderItem' that takes parameters 'params' and 'api' . Category Index Extraction: Extract the category index from the value at index 0 using 'api.value(0)' . Calculate Start Coordinate: Calculate the start coordinate based on the value at index 1 and the extracted category index. Calculate End Coordinate: Calculate the end coordinate based on the value at index 2 and the extracted category index. Calculate Height: Calculate the height as a fraction (30%) of the total height of the chart. Create Clipped Rectangle Shape: Use echarts.graphic.clipRectByRect to create a clipped rectangle shape based on the calculated start, end, and height. Return Rectangle Shape: If 'rectShape' exists, return a rectangle shape with type, transition, shape, and style information. Production Button Functionalities: Production Button Click Event: The 'Production' button is configured to respond to the click event using the '@click' directive. When the button is clicked, the 'showProductionPopup' function is invoked. Function Invocation: The 'showProductionPopup' function is called with an argument ( 'row.itemno' ). The purpose and functionality of the 'showProductionPopup' function would be determined by the implementation in the Vue.js component's script. Popup Container: If the 'isProductionVisible' variable is true, display a fixed-positioned container covering the entire screen, centered both vertically and horizontally. Production Component Display Section: Within the container, create a rounded and shadowed section with a white background, providing padding. Render Production Component: Inside this section, render a 'Production' component with a height of 96 units, passing in 'ParentProductionData' as a prop. Epoch to DateTime Conversion: The 'epochToDateTimeString' function converts an epoch timestamp to a formatted date-time string. Fetch Data Function: The 'fetchData' function is an asynchronous function that fetches production data using Axios. Watch for Prop Changes: The 'watch' function observes changes in the ' dataFromParentProduction ' prop and triggers the 'fetchData' function accordingly. Calculate Total Duration: The 'calculateTotalDuration' function calculates the total duration for a specific state (IDLE or PRODUCTION) based on data points. Format Duration Function: The 'formatDuration' function formats a duration in milliseconds into hours, minutes, and seconds. Component Mount: The 'onMounted' lifecycle hook ensures that the 'fetchData' function is executed when the component is mounted. Edit/Save Button Functionalities: Asynchronous Data Saving Function: The 'saveEditedData' function is asynchronous and handles the process of saving edited data. Original Type Storage: The original type of the row is stored before making changes. HTTP PUT Request for Data Update: An HTTP PUT request is made to update data based on the edited row using the axios library. Edited Type Extraction: The edited type is extracted from the response data. Data and Graph Updates: Operator data and graph data are updated based on the edited row. Toggle Editing Status: The editing status of the row is toggled. Fetch Recent Data: Recent data is fetched from a FastAPI endpoint for the specific machine and operator. Filter Data for Operator: Data is filtered for the specific operator. Most Recent Data Identification: The most recent data entry is identified based on the timestamp. Time Conversion to Epoch-Time : - Start and end times from the most recent data are converted to epoch-time. Element Type Change Check: Checks if the element type has changed. HTTP POST Request for New Entry: If the element type has changed, a new entry is created using an HTTP POST request. Error Handling: Errors during the process are handled and logged. Project Functionalities Overview for Machine-Scheduling Page: Add Machine Button Functionalities: New Machine Object Creation: A new machine object is created with default values based on the form data. String Version Creation: A string version of the new machine object is created, including formatted date-time strings using the moment library. HTTP POST Request: An HTTP POST request is made to save the new machine data to the backend using the axios library. Table Data Update: The new machine, represented as a string, is added to the table data. Form Reset and Visibility Toggle: The form data is reset, and the visibility of the form is set to false. Error Handling: Errors during the process are handled and logged, allowing for appropriate error handling (e.g., displaying an error message). Apply Filter Logic Functionalities: Filtering Process: The function filters the 'tableData' based on specified filter criteria: 'operatorName' , 'machineId' , and 'startDate' . Filter Conditions: Checks if there is a match for the operator name, machine ID, and start date based on the provided filter values. If no filter is applied for a specific criterion, it considers it a match. Date Comparison: Extracts the date part from the timestamp and compares it with the filter date, ensuring a match when the dates are equal. Resulting Data: Constructs a new array ( 'filteredData' ) containing the entries that meet all filter conditions. Update Table Data: Updates the 'tableData' with the filtered results, displaying only the entries that match the applied filters. Hide Filter Form: Sets the visibility of the filter form to false, hiding it after applying the filters. Download Table Excel Button Functionalities: HTTP GET Request: An HTTP GET request is made using Axios to fetch operational shift data. Console Logging: The fetched operational shift data is logged to the console for verification. Data Conversion: The response data is converted to an array format, ensuring consistency. Data Update: TThe reactive data variable ( 'data.value' ) is updated with the fetched data. Excel Sheet Generation: JSON data is converted to an Excel sheet using the XLSX library. Workbook Creation: A new Excel workbook is created using the XLSX library. Sheet Appending: The generated sheet is appended to the workbook with the sheet name ' DataSheet '. File Writing: The workbook is written to an Excel file named 'tableExcel.xlsx' . Error Handling: Errors during the process are handled and logged, allowing for appropriate error handling (e.g., displaying an error message). Download Production Data Button Functionalities: Visibility Toggle: The form is displayed ( 'v-if=\"isProductionFormVisible\"' ) in the center of the screen. Form Structure: The form consists of input fields for selecting a machine name, start date, and end date. Machine Name Selection: A dropdown menu allows the user to select a machine name, populated dynamically from the 'machineIds' array. Start Date Input: An input field for selecting the start date using the 'startDateProd' variable. End Date Input: An input field for selecting the end date using the 'endDateProdProd' variable. Form Submission Buttons: Two buttons at the bottom of the form: 'Download Button:' - Triggers the 'generateProductionExcel' method on form submission. 'Cancel Button:' - Calls the 'cancelProductionForm' method to cancel and close the form. Event Handling: The '@submit.prevent' directive prevents the default form submission behavior. Styling: The form is styled with a specific width, padding, background color, borders, and shadow for a visually appealing layout. Field Validation: Checks if essential fields (machine ID, start date, and end date) are filled; displays an alert if not. Date Formatting: Formats the start and end dates using the 'moment' library. Backend API URL: Constructs the backend API URL for fetching production data based on the selected machine and date range. Fetch Production Data: Makes an asynchronous request to the backend to retrieve production data. Success Handling: If successful, logs the success message, processes the response data, and triggers the download of an Excel file. Error Handling: Handles errors by providing specific messages based on the type of error, including HTTP status codes and validation errors. Form Reset and Visibility: Resets the form and hides it after successful data processing and download. Delete Data Logic Functionalities: Timestamp Conversion: Converts the start and end times from the input format to Unix timestamps using the 'moment' library. URL Encoding: Encodes the element and operator names for safe inclusion in the URL. URL Construction: Constructs the URL for the DELETE request based on the specified parameters. DELETE Request: Makes an asynchronous DELETE request to the backend API to delete the specified data. Success Handling: If successful, logs the success message, updates the table data by removing the deleted entry, and triggers a page reload after a short delay. Error Handling: Handles errors by logging and displaying an error message in case the deletion fails. Project Functionalities Overview for Element-Master Page: Add Element Type Button Functionalities: Validation: The function begins by validating the format of both standard current and voltage. Validation Errors Check: If there are validation errors, the function halts further execution to prevent form submission. Form Data Preparation: Constructs the form data object with various properties, including type, range, standard current, and standard voltage. HTTP POST Request: Utilizes axios to make an asynchronous POST request to the FastAPI backend, sending the form data. Response Handling: Logs a success message and sets an alert message indicating the successful creation of the element. Form Reset and Visibility: Resets the form fields, hides the form, and triggers a data fetch to update the table. Error Handling: Catches any errors that may occur during the process and handles them appropriately, displaying relevant error messages. Project Functionalities Overview for Report Page: Filtering Data Functionalities: Endpoint Definitions: The function defines various endpoints for different parameters, each representing a specific type of data. Data Fetching Loop: The function iterates through each parameter in the defined endpoints and makes asynchronous GET requests using axios. Options Extraction: For each parameter, the response data is extracted using a helper function ( 'extractOptions' ) and stored in the 'availableOptions' object. Deduplication and Update: Specific parameters in the 'availableOptions' object, such as 'range,' 'project,' etc., are deduplicated to ensure unique values. Error Handling: The function includes error handling to log any errors that may occur during the fetching process. Options Extraction Function: The 'extractOptions' function is a helper that extracts options from response data based on the specified parameter. It handles different response structures. Form Submission Function: The 'submitForm' function makes a GET request to a specified endpoint ( 'http://172.18.100.240:6969/excel/' ) with form data as parameters. It checks the response for data and handles success or no-data scenarios. Excel Download Function: The 'downloadExcel' function converts filtered values to an Excel sheet using XLSX, appends it to a new workbook, and downloads the workbook as an Excel file. OnMount Data Fetch: The 'onMounted' lifecycle hook ensures that the 'fetchDataForParameters' function is executed when the component is mounted. This function likely populates available options for form parameters.","title":"Frontend services"},{"location":"frontend.html#introduction","text":"Project Overview: IoT Based Data Acquisition And Machine Monitoring For Welding Machine[GerbIndia]","title":"Introduction"},{"location":"frontend.html#frontend-technologies","text":"","title":"Frontend Technologies"},{"location":"frontend.html#frontend-stack-overview","text":"The project's frontend utilizes a modern tech stack including HTML5 for markup, CSS3 for styling, Tailwind CSS for utility-first styling, JavaScript for scripting, Vue3.js as the JavaScript framework, and Axios for handling HTTP requests.","title":"Frontend Stack Overview"},{"location":"frontend.html#prerequisites","text":"","title":"Prerequisites"},{"location":"frontend.html#creating-a-vue-3-project","text":"To create a Vue 3 project, you can use the Vue CLI (Command Line Interface), which is a standard tool for Vue.js development. Follow these steps: Install Node.js and npm: Before creating a Vue project, ensure that you have Node.js and npm (Node Package Manager) installed on your machine. You can download and install them from https://nodejs.org/ . Install Vue CLI: Open a terminal or command prompt and install the Vue CLI globally by running the following command: npm install -g @vue/cli Create a New Project: Navigate to the directory where you want to create your Vue 3 project using the cd command. Run the following command to create a new Vue 3 project: vue create project-name Configure Project Settings: The Vue CLI will prompt you to pick a preset. Choose \"Default ([Vue 3] babel, eslint)\" for a project with Vue 3, Babel, and ESLint. Alternatively, you can manually select features based on your project requirements. Project Initialization: Once the project is created, navigate into the project directory: cd project-name Run the Development Server: To start the development server and see your project in action, run: npm run serve Explore and Customize: Open the project in your preferred code editor. Explore the src directory where your main application code is located. Customize the project according to your needs by modifying components, adding new features, and integrating external libraries.","title":"Creating a Vue 3 Project"},{"location":"frontend.html#adding-tailwind-css-to-vue-3-project","text":"To add Tailwind CSS to a Vue 3 project created with the Vue CLI, you can follow these steps: Install Tailwind CSS and its Dependencies: Open a terminal in the root of your Vue 3 project. Install Tailwind CSS, PostCSS, and Autoprefixer by running the following command: npm install -D tailwindcss postcss autoprefixer Generate Tailwind Configuration Files: Create a configuration file for Tailwind CSS by running: npx tailwindcss init -p - This will generate a tailwind.config.js file and a postcss.config.js file in your project's root directory. Configure PostCSS: Open the postcss.config.js file and ensure it includes the following plugins: module.exports = { plugins: { tailwindcss: {}, autoprefixer: {}, } } Create Styles Entry Point: Create a new file, for example, src/styles/tailwind.css to serve as your styles entry point. /* src/styles/tailwind.css */ @import 'tailwindcss/base'; @import 'tailwindcss/components'; @import 'tailwindcss/utilities'; Import Tailwind CSS in Main Styles File: Open your main styles file, usually src/assets/styles/main.css, and import the Tailwind CSS styles: /* src/assets/styles/main.css */ @import './tailwind.css'; /* Your existing styles go here */ Update Build Configuration: Open vue.config.js in the root of your project (create it if it doesn't exist) and add the following configuration: // vue.config.js module.exports = { css: { loaderOptions: { postcss: { plugins: [ require('tailwindcss'), require('autoprefixer'), ], }, }, }, } Use Tailwind CSS Classes: You can now use Tailwind CSS classes in your Vue components. For example, in your Vue component's template: <template> <div class=\"bg-blue-500 text-white p-4\"> This is a Tailwind CSS component! </div> </template> Run the Development Server: Start or restart your development server: npm run serve","title":"Adding Tailwind CSS to Vue 3 Project:"},{"location":"frontend.html#file-structure","text":"In Vue.js 3, the file structure is flexible and depends on the complexity and requirements of your project. However, there are common conventions that you can follow to organize your Vue.js project in a clean and maintainable way. Here's a step-by-step explanation of a typical file structure for a Vue.js 3 project: Project Root: At the root of your project, you might find configuration files like package.json , babel.config.js , and vue.config.js . src Folder: The src folder is where your main source code resides. Assets: The assets folder contains static assets like images, fonts, and stylesheets. src/ |- assets/ |- images/ |- ak400.png |- styles/ Components: The components folder is where you store your Vue components. You can organize them further based on features or functionalities. src/ |- components/ |- elementMaster.vue |- filterTable.vue |- welder.vue |- ... Views/Pages: The views or pages folder is where you store higher-level components that represent pages or views in your application. src/ |- views/ |- Home.vue |- elementMasterTable.vue |- weldertable.vue |- ... Router: If you're using Vue Router for navigation, you might have a router folder to manage your routes. src/ |- router/ |- index.js Store (State Management): If you're using Vuex for state management, you might have a store folder. src/ |- store/ |- index.js |- modules/ Plugins: The plugins folder can contain Vue plugins or third-party integrations. src/ |- plugins/ |- axios.js","title":"File Structure"},{"location":"frontend.html#commands","text":"npm run dev - Start the development server and run the Vue 3 project. npm run build - Build the Vue 3 project for production deployment.","title":"Commands"},{"location":"frontend.html#implementation","text":"Certainly! Now, I will provide an explanation for the functionalities of each component:","title":"Implementation"},{"location":"frontend.html#how-to-generate-a-component-and-its-corresponding-syntax","text":"Creating a Basic Component: Start by creating a new .vue file, for example, MyComponent.vue . <!-- MyComponent.vue --> <template> <div> <!-- Your component's template goes here --> <h1>{{ message }}</h1> </div> </template> <script> export default { data() { return { message: 'Hello, Vue!' }; } } </script> <style scoped> /* Your component-specific styles go here */ h1 { color: blue; } </style> Vue Component Syntax Breakdown: <template>: Contains the HTML structure of the component. <script>: Contains the JavaScript code for the component. <style>: Contains the component's styles (use scoped attribute to scope styles to the component).","title":"How to generate a component and its corresponding syntax."},{"location":"frontend.html#project-functionalities-overview-for-welder-page","text":"","title":"Project Functionalities Overview for Welder Page:"},{"location":"frontend.html#live-button-functionalities","text":"Live Button Click Event: The \"Live\" button is configured to respond to the click event using the @click directive. When the button is clicked, the \"showUserLiveCurrentPopup\" function is invoked. Function Invocation: - Build the Vue 3 project for production deployment. The \"showUserLiveCurrentPopup\" function is called with an argument ( row.itemno ). The purpose and functionality of the \"showUserLiveCurrentPopup\" function are determined by the implementation in the Vue.js component or script associated with this template. Visibility Toggle: The function sets a reactive variable ( 'isUserLiveCurrentPopupVisible' ) to 'true' , making the user live current popup visible. Graph Data Configuration: The 'machineId' parameter is assigned to the 'graphData' object, updating the machineId for graph data. HTTP GET Request: An Axios HTTP GET request is made to fetch live data for the specified 'machineId' from a given endpoint. Data Validation: Checks if there is data in the response and if the array is not empty. Data Extraction: Extracts specific values (low and high standard voltage, low and high standard current) from the response data. Graph Data Update: Updates the 'graphData' object with the extracted range values. Console Logging: Logs the low standard voltage value to the console. Error Handling: Logs an error if there is no data or the array is empty in the response. Assumption: Assumes the existence of a 'sendata' function, commented out but not implemented, to update range values. The 'sendata' function is expected to be defined elsewhere in the component. Error Logging: Logs an error if there is an issue fetching data from the server.","title":"Live Button Functionalities:"},{"location":"frontend.html#all-stats-button-functionalities","text":"All Stats Button Click Event: The 'All Stats' button is configured to respond to the click event using the '@click' directive. When the button is clicked, the 'showStackPopup' function is invoked. Function Invocation: The 'showStackPopup' function is called. The purpose and functionality of the 'showStackPopup' function would be determined by the implementation in the Vue.js component's script. Popup Container: If the 'isStackVisible' variable is true, display a fixed-positioned container covering the entire screen, centered both vertically and horizontally. Chart Display Section: Within the container, create a rounded and shadowed section with a white background, providing padding. Render Stack Chart Component: Inside this section, render a 'Stack' chart component with a height of 96 units, passing in 'stateChartData' as a prop. Close Button: Include a close button at the top-right corner of the container. Close Icon: The close button contains an \"X\" icon sourced from an external URL, serving as a visual representation of closing the popup. Define Props: The component defines a prop named 'chartData' with default values representing a chart's minimum timestamp and data points. Render Item Function: The component has a function named 'renderItem' that takes parameters 'params' and 'api' . Category Index Extraction: Extract the category index from the value at index 0 using 'api.value(0)' . Calculate Start Coordinate: Calculate the start coordinate based on the value at index 1 and the extracted category index. Calculate End Coordinate: Calculate the end coordinate based on the value at index 2 and the extracted category index. Calculate Height: Calculate the height as a fraction (30%) of the total height of the chart. Create Clipped Rectangle Shape: Use echarts.graphic.clipRectByRect to create a clipped rectangle shape based on the calculated start, end, and height. Return Rectangle Shape: If 'rectShape' exists, return a rectangle shape with type, transition, shape, and style information.","title":"All Stats Button Functionalities:"},{"location":"frontend.html#production-button-functionalities","text":"Production Button Click Event: The 'Production' button is configured to respond to the click event using the '@click' directive. When the button is clicked, the 'showProductionPopup' function is invoked. Function Invocation: The 'showProductionPopup' function is called with an argument ( 'row.itemno' ). The purpose and functionality of the 'showProductionPopup' function would be determined by the implementation in the Vue.js component's script. Popup Container: If the 'isProductionVisible' variable is true, display a fixed-positioned container covering the entire screen, centered both vertically and horizontally. Production Component Display Section: Within the container, create a rounded and shadowed section with a white background, providing padding. Render Production Component: Inside this section, render a 'Production' component with a height of 96 units, passing in 'ParentProductionData' as a prop. Epoch to DateTime Conversion: The 'epochToDateTimeString' function converts an epoch timestamp to a formatted date-time string. Fetch Data Function: The 'fetchData' function is an asynchronous function that fetches production data using Axios. Watch for Prop Changes: The 'watch' function observes changes in the ' dataFromParentProduction ' prop and triggers the 'fetchData' function accordingly. Calculate Total Duration: The 'calculateTotalDuration' function calculates the total duration for a specific state (IDLE or PRODUCTION) based on data points. Format Duration Function: The 'formatDuration' function formats a duration in milliseconds into hours, minutes, and seconds. Component Mount: The 'onMounted' lifecycle hook ensures that the 'fetchData' function is executed when the component is mounted.","title":"Production Button Functionalities:"},{"location":"frontend.html#editsave-button-functionalities","text":"Asynchronous Data Saving Function: The 'saveEditedData' function is asynchronous and handles the process of saving edited data. Original Type Storage: The original type of the row is stored before making changes. HTTP PUT Request for Data Update: An HTTP PUT request is made to update data based on the edited row using the axios library. Edited Type Extraction: The edited type is extracted from the response data. Data and Graph Updates: Operator data and graph data are updated based on the edited row. Toggle Editing Status: The editing status of the row is toggled. Fetch Recent Data: Recent data is fetched from a FastAPI endpoint for the specific machine and operator. Filter Data for Operator: Data is filtered for the specific operator. Most Recent Data Identification: The most recent data entry is identified based on the timestamp. Time Conversion to Epoch-Time : - Start and end times from the most recent data are converted to epoch-time. Element Type Change Check: Checks if the element type has changed. HTTP POST Request for New Entry: If the element type has changed, a new entry is created using an HTTP POST request. Error Handling: Errors during the process are handled and logged.","title":"Edit/Save Button Functionalities:"},{"location":"frontend.html#project-functionalities-overview-for-machine-scheduling-page","text":"","title":"Project Functionalities Overview for Machine-Scheduling Page:"},{"location":"frontend.html#add-machine-button-functionalities","text":"New Machine Object Creation: A new machine object is created with default values based on the form data. String Version Creation: A string version of the new machine object is created, including formatted date-time strings using the moment library. HTTP POST Request: An HTTP POST request is made to save the new machine data to the backend using the axios library. Table Data Update: The new machine, represented as a string, is added to the table data. Form Reset and Visibility Toggle: The form data is reset, and the visibility of the form is set to false. Error Handling: Errors during the process are handled and logged, allowing for appropriate error handling (e.g., displaying an error message).","title":"Add Machine Button Functionalities:"},{"location":"frontend.html#apply-filter-logic-functionalities","text":"Filtering Process: The function filters the 'tableData' based on specified filter criteria: 'operatorName' , 'machineId' , and 'startDate' . Filter Conditions: Checks if there is a match for the operator name, machine ID, and start date based on the provided filter values. If no filter is applied for a specific criterion, it considers it a match. Date Comparison: Extracts the date part from the timestamp and compares it with the filter date, ensuring a match when the dates are equal. Resulting Data: Constructs a new array ( 'filteredData' ) containing the entries that meet all filter conditions. Update Table Data: Updates the 'tableData' with the filtered results, displaying only the entries that match the applied filters. Hide Filter Form: Sets the visibility of the filter form to false, hiding it after applying the filters.","title":"Apply Filter Logic Functionalities:"},{"location":"frontend.html#download-table-excel-button-functionalities","text":"HTTP GET Request: An HTTP GET request is made using Axios to fetch operational shift data. Console Logging: The fetched operational shift data is logged to the console for verification. Data Conversion: The response data is converted to an array format, ensuring consistency. Data Update: TThe reactive data variable ( 'data.value' ) is updated with the fetched data. Excel Sheet Generation: JSON data is converted to an Excel sheet using the XLSX library. Workbook Creation: A new Excel workbook is created using the XLSX library. Sheet Appending: The generated sheet is appended to the workbook with the sheet name ' DataSheet '. File Writing: The workbook is written to an Excel file named 'tableExcel.xlsx' . Error Handling: Errors during the process are handled and logged, allowing for appropriate error handling (e.g., displaying an error message).","title":"Download Table Excel Button Functionalities:"},{"location":"frontend.html#download-production-data-button-functionalities","text":"Visibility Toggle: The form is displayed ( 'v-if=\"isProductionFormVisible\"' ) in the center of the screen. Form Structure: The form consists of input fields for selecting a machine name, start date, and end date. Machine Name Selection: A dropdown menu allows the user to select a machine name, populated dynamically from the 'machineIds' array. Start Date Input: An input field for selecting the start date using the 'startDateProd' variable. End Date Input: An input field for selecting the end date using the 'endDateProdProd' variable. Form Submission Buttons: Two buttons at the bottom of the form: 'Download Button:' - Triggers the 'generateProductionExcel' method on form submission. 'Cancel Button:' - Calls the 'cancelProductionForm' method to cancel and close the form. Event Handling: The '@submit.prevent' directive prevents the default form submission behavior. Styling: The form is styled with a specific width, padding, background color, borders, and shadow for a visually appealing layout. Field Validation: Checks if essential fields (machine ID, start date, and end date) are filled; displays an alert if not. Date Formatting: Formats the start and end dates using the 'moment' library. Backend API URL: Constructs the backend API URL for fetching production data based on the selected machine and date range. Fetch Production Data: Makes an asynchronous request to the backend to retrieve production data. Success Handling: If successful, logs the success message, processes the response data, and triggers the download of an Excel file. Error Handling: Handles errors by providing specific messages based on the type of error, including HTTP status codes and validation errors. Form Reset and Visibility: Resets the form and hides it after successful data processing and download.","title":"Download Production Data Button Functionalities:"},{"location":"frontend.html#delete-data-logic-functionalities","text":"Timestamp Conversion: Converts the start and end times from the input format to Unix timestamps using the 'moment' library. URL Encoding: Encodes the element and operator names for safe inclusion in the URL. URL Construction: Constructs the URL for the DELETE request based on the specified parameters. DELETE Request: Makes an asynchronous DELETE request to the backend API to delete the specified data. Success Handling: If successful, logs the success message, updates the table data by removing the deleted entry, and triggers a page reload after a short delay. Error Handling: Handles errors by logging and displaying an error message in case the deletion fails.","title":"Delete Data Logic Functionalities:"},{"location":"frontend.html#project-functionalities-overview-for-element-master-page","text":"","title":"Project Functionalities Overview for Element-Master Page:"},{"location":"frontend.html#add-element-type-button-functionalities","text":"Validation: The function begins by validating the format of both standard current and voltage. Validation Errors Check: If there are validation errors, the function halts further execution to prevent form submission. Form Data Preparation: Constructs the form data object with various properties, including type, range, standard current, and standard voltage. HTTP POST Request: Utilizes axios to make an asynchronous POST request to the FastAPI backend, sending the form data. Response Handling: Logs a success message and sets an alert message indicating the successful creation of the element. Form Reset and Visibility: Resets the form fields, hides the form, and triggers a data fetch to update the table. Error Handling: Catches any errors that may occur during the process and handles them appropriately, displaying relevant error messages.","title":"Add Element Type Button Functionalities:"},{"location":"frontend.html#project-functionalities-overview-for-report-page","text":"","title":"Project Functionalities Overview for Report Page:"},{"location":"frontend.html#filtering-data-functionalities","text":"Endpoint Definitions: The function defines various endpoints for different parameters, each representing a specific type of data. Data Fetching Loop: The function iterates through each parameter in the defined endpoints and makes asynchronous GET requests using axios. Options Extraction: For each parameter, the response data is extracted using a helper function ( 'extractOptions' ) and stored in the 'availableOptions' object. Deduplication and Update: Specific parameters in the 'availableOptions' object, such as 'range,' 'project,' etc., are deduplicated to ensure unique values. Error Handling: The function includes error handling to log any errors that may occur during the fetching process. Options Extraction Function: The 'extractOptions' function is a helper that extracts options from response data based on the specified parameter. It handles different response structures. Form Submission Function: The 'submitForm' function makes a GET request to a specified endpoint ( 'http://172.18.100.240:6969/excel/' ) with form data as parameters. It checks the response for data and handles success or no-data scenarios. Excel Download Function: The 'downloadExcel' function converts filtered values to an Excel sheet using XLSX, appends it to a new workbook, and downloads the workbook as an Excel file. OnMount Data Fetch: The 'onMounted' lifecycle hook ensures that the 'fetchDataForParameters' function is executed when the component is mounted. This function likely populates available options for form parameters.","title":"Filtering Data Functionalities:"},{"location":"troubleshoot.html","text":"Introduction In this section of the documentation, you will find solutions addressing common issues that may arise. How to add a new machine? Backend Navigate to the database, select the 'Schemas' tab, locate the 'Table' (Machine), right-click, and choose 'Script' to generate and insert the script. 2.Modify the values to reflect the appropriate data for the 'Machine' table. Frontend To add a new machine to the existing dataRows array in your JavaScript code, follow these steps: 1. Identify the Next Available ID: Find the last item in the dataRows array and determine its ID. Assign the new machine's ID as the next number after the last ID. 2. Create a New Machine Object: Copy one of the commented-out machine objects (e.g., the commented-out block for the 7D machine) as a template. Replace the placeholder values (e.g., '7D', 'AK-400-2-7D', etc.) with the actual values for the new machine. 3. Update Image Path: Replace the machineimg value with the correct path to the image for the new machine. 4. Add the New Machine Object to dataRows: Uncomment the copied machine object by removing the // from the beginning of each line. Add the new machine object to the dataRows array. 5. Update Data Binding: If your application relies on data binding, make sure to update the corresponding bindings in your application code to include the new machine data. How to use docker? Using Docker for Containerized Deployment Follow these steps to build, tag, push, and run your Docker container: Build the Docker Image : docker build -t <img_name>:<tag_name> . This command builds a Docker image using the Dockerfile in the current directory, tagging it with the specified image name and version. Tag the Docker Image: docker tag <img_name>:<tag_name> <username>/<repo_name>:<tag> Tag the previously built image with your Docker Hub username, repository name, and desired version tag. Login to Docker Hub: Ensure you are logged in to Docker Hub before pushing the image. Use the following command and follow the prompts. docker login Push the Docker Image: docker push <username>/<repo_name>:<tag_name> Upload the tagged Docker image to your Docker Hub repository. Run the Docker Container: docker run -e --name <container_name> -p <p_num>:<p_num> <username>/<repo_name>:<tag_name> Deploy a container from the specified image, setting environment variables and mapping ports as needed. Key Points: Ensure you replace placeholders such as img_name, tag_name, username, repo_name, and container_name with your actual values. The -e option in the docker run command sets an environment variable in the container. Adjust the IP address, port mappings, and any other parameters based on your specific requirements.","title":"Troubleshooting"},{"location":"troubleshoot.html#introduction","text":"In this section of the documentation, you will find solutions addressing common issues that may arise.","title":"Introduction"},{"location":"troubleshoot.html#how-to-add-a-new-machine","text":"","title":"How to add a new machine?"},{"location":"troubleshoot.html#backend","text":"Navigate to the database, select the 'Schemas' tab, locate the 'Table' (Machine), right-click, and choose 'Script' to generate and insert the script. 2.Modify the values to reflect the appropriate data for the 'Machine' table.","title":"Backend"},{"location":"troubleshoot.html#frontend","text":"To add a new machine to the existing dataRows array in your JavaScript code, follow these steps: 1. Identify the Next Available ID: Find the last item in the dataRows array and determine its ID. Assign the new machine's ID as the next number after the last ID. 2. Create a New Machine Object: Copy one of the commented-out machine objects (e.g., the commented-out block for the 7D machine) as a template. Replace the placeholder values (e.g., '7D', 'AK-400-2-7D', etc.) with the actual values for the new machine. 3. Update Image Path: Replace the machineimg value with the correct path to the image for the new machine. 4. Add the New Machine Object to dataRows: Uncomment the copied machine object by removing the // from the beginning of each line. Add the new machine object to the dataRows array. 5. Update Data Binding: If your application relies on data binding, make sure to update the corresponding bindings in your application code to include the new machine data.","title":"Frontend"},{"location":"troubleshoot.html#how-to-use-docker","text":"","title":"How to use docker?"},{"location":"troubleshoot.html#using-docker-for-containerized-deployment","text":"Follow these steps to build, tag, push, and run your Docker container: Build the Docker Image : docker build -t <img_name>:<tag_name> . This command builds a Docker image using the Dockerfile in the current directory, tagging it with the specified image name and version. Tag the Docker Image: docker tag <img_name>:<tag_name> <username>/<repo_name>:<tag> Tag the previously built image with your Docker Hub username, repository name, and desired version tag. Login to Docker Hub: Ensure you are logged in to Docker Hub before pushing the image. Use the following command and follow the prompts. docker login Push the Docker Image: docker push <username>/<repo_name>:<tag_name> Upload the tagged Docker image to your Docker Hub repository. Run the Docker Container: docker run -e --name <container_name> -p <p_num>:<p_num> <username>/<repo_name>:<tag_name> Deploy a container from the specified image, setting environment variables and mapping ports as needed.","title":"Using Docker for Containerized Deployment"},{"location":"troubleshoot.html#key-points","text":"Ensure you replace placeholders such as img_name, tag_name, username, repo_name, and container_name with your actual values. The -e option in the docker run command sets an environment variable in the container. Adjust the IP address, port mappings, and any other parameters based on your specific requirements.","title":"Key Points:"},{"location":"ui.html","text":"Managing GerbIndia : IOT Based Machine Monitoring Dashboard . Powered by - CMTI view Creation Date: January 2, 2024 Created By: CMTI Company View most recent version on GerbIndia Project IOT Based Machine Monitoring Dashboard - GerbIndia 1. Please provide a username or email along with a password to log in. 2. Enter the credentials and click the login button to access the welder page. 3. On the welder page, machine states are displayed, indicating production and idle states. 4. Access specific details for the 7G machine. 5. Click on the edit button to modify plate thickness, plate description, element description, type, standard current, standard voltage, and remarks. 6. Make changes in the input fields and save the updated data. 7. Click on the live button to access real-time graphs for current and voltage. 8. Display the real-time data for actual current and actual voltage. 9. Select the \"All States\" button to view production and idle states for all machines on a specific day. 10. Retrieve the production and idle states for all machines on a specific day. 11. Click on the production button to see production and idle states for a chosen date. 12. Choose a date and click \"Submit\" to view the production and idle states for the selected date of a specific machine. 13. Now, navigate to the 'Machine Schedule' component by clicking on the corresponding option in the navbar. 14. Click on 'Add Schedule' for either the current day's work or for the upcoming week's tasks. 15. Complete all the required fields, then click 'Create' to generate the schedule list. 16. Review the recently added schedule information for the machine named 27E. 17. Utilize the search filter to narrow down the table data. 18. Enter the desired fields and click 'Apply Filters' to display the filtered table data. 19. Reset filters to undo any entered data and restore the original table. 20. \"Select 'Download Table Excel' to export the table data to an Excel sheet. 21. Download specific machine data for a particular date by clicking on 'Download Production Data. 22. Choose the machine name, start time, and end time, then click 'Download' to obtain data for that specific machine on the selected dates. 23. Click on the 'Edit' button to modify the data. 24. Click 'Update' to save the edited data in the table. 25. Utilize the 'Delete' button to remove specific machine data. 26. Access all elements of the table data. 27. Select 'Add Element Type' to introduce a new element type. 28. Enter data into all the required fields. Click on the 'Create' button to generate a new element type. 29. Utilize the 'Edit' button to modify the fields. 30. After editing, the updated data is immediately reflected in the table. 31. Click on the 'Delete' button to remove specific element data. 32. Select 'Add Welder Details' to introduce another set of details. 33. Enter data into all the required fields. Click on the 'Create' button to generate new welder details. 34. Utilize the 'Edit' button to modify the fields. 35. After editing, the updated data is immediately reflected in the table. 36. Click on the 'Delete' button to remove specific welder details. 37. Select 'Add Project Details' to introduce another set of project details. 38. Enter data into all the required fields. Click on the 'Create' button to generate new project details. 39. Utilize the 'Edit' button to modify the fields. 40. After editing, the updated data is immediately reflected in the table. 41. Click on the 'Delete' button to remove specific project details. 42. Navigate to the Report menu in the Navbar to get the data in the Excel Format 43. now you can enter any fields and click on submit button 44. to filter the data and showing in the table 45. click on download excel the particulare table data showing will displaying excel sheet","title":"User Interface"},{"location":"ui.html#managing-gerbindia-iot-based-machine-monitoring-dashboard","text":"","title":"Managing GerbIndia : IOT Based Machine Monitoring Dashboard ."},{"location":"ui.html#powered-by-cmti","text":"view Creation Date: January 2, 2024 Created By: CMTI Company View most recent version on GerbIndia Project","title":"Powered by - CMTI"},{"location":"ui.html#iot-based-machine-monitoring-dashboard-gerbindia","text":"","title":"IOT Based Machine Monitoring Dashboard - GerbIndia"},{"location":"ui.html#1-please-provide-a-username-or-email-along-with-a-password-to-log-in","text":"","title":"1. Please provide a username or email along with a password to log in."},{"location":"ui.html#2-enter-the-credentials-and-click-the-login-button-to-access-the-welder-page","text":"","title":"2. Enter the credentials and click the login button to access the welder page."},{"location":"ui.html#3-on-the-welder-page-machine-states-are-displayed-indicating-production-and-idle-states","text":"","title":"3. On the welder page, machine states are displayed, indicating production and idle states."},{"location":"ui.html#4-access-specific-details-for-the-7g-machine","text":"","title":"4. Access specific details for the 7G machine."},{"location":"ui.html#5-click-on-the-edit-button-to-modify-plate-thickness-plate-description-element-description-type-standard-current-standard-voltage-and-remarks","text":"","title":"5. Click on the edit button to modify plate thickness, plate description, element description, type, standard current, standard voltage, and remarks."},{"location":"ui.html#6-make-changes-in-the-input-fields-and-save-the-updated-data","text":"","title":"6. Make changes in the input fields and save the updated data."},{"location":"ui.html#7-click-on-the-live-button-to-access-real-time-graphs-for-current-and-voltage","text":"","title":"7. Click on the live button to access real-time graphs for current and voltage."},{"location":"ui.html#8-display-the-real-time-data-for-actual-current-and-actual-voltage","text":"","title":"8. Display the real-time data for actual current and actual voltage."},{"location":"ui.html#9-select-the-all-states-button-to-view-production-and-idle-states-for-all-machines-on-a-specific-day","text":"","title":"9. Select the \"All States\" button to view production and idle states for all machines on a specific day."},{"location":"ui.html#10-retrieve-the-production-and-idle-states-for-all-machines-on-a-specific-day","text":"","title":"10. Retrieve the production and idle states for all machines on a specific day."},{"location":"ui.html#11-click-on-the-production-button-to-see-production-and-idle-states-for-a-chosen-date","text":"","title":"11. Click on the production button to see production and idle states for a chosen date."},{"location":"ui.html#12-choose-a-date-and-click-submit-to-view-the-production-and-idle-states-for-the-selected-date-of-a-specific-machine","text":"","title":"12. Choose a date and click \"Submit\" to view the production and idle states for the selected date of a specific machine."},{"location":"ui.html#13-now-navigate-to-the-machine-schedule-component-by-clicking-on-the-corresponding-option-in-the-navbar","text":"","title":"13. Now, navigate to the 'Machine Schedule' component by clicking on the corresponding option in the navbar."},{"location":"ui.html#14-click-on-add-schedule-for-either-the-current-days-work-or-for-the-upcoming-weeks-tasks","text":"","title":"14. Click on 'Add Schedule' for either the current day's work or for the upcoming week's tasks."},{"location":"ui.html#15-complete-all-the-required-fields-then-click-create-to-generate-the-schedule-list","text":"","title":"15. Complete all the required fields, then click 'Create' to generate the schedule list."},{"location":"ui.html#16-review-the-recently-added-schedule-information-for-the-machine-named-27e","text":"","title":"16. Review the recently added schedule information for the machine named 27E."},{"location":"ui.html#17-utilize-the-search-filter-to-narrow-down-the-table-data","text":"","title":"17. Utilize the search filter to narrow down the table data."},{"location":"ui.html#18-enter-the-desired-fields-and-click-apply-filters-to-display-the-filtered-table-data","text":"","title":"18. Enter the desired fields and click 'Apply Filters' to display the filtered table data."},{"location":"ui.html#19-reset-filters-to-undo-any-entered-data-and-restore-the-original-table","text":"","title":"19. Reset filters to undo any entered data and restore the original table."},{"location":"ui.html#20-select-download-table-excel-to-export-the-table-data-to-an-excel-sheet","text":"","title":"20. \"Select 'Download Table Excel' to export the table data to an Excel sheet."},{"location":"ui.html#21-download-specific-machine-data-for-a-particular-date-by-clicking-on-download-production-data","text":"","title":"21. Download specific machine data for a particular date by clicking on 'Download Production Data."},{"location":"ui.html#22-choose-the-machine-name-start-time-and-end-time-then-click-download-to-obtain-data-for-that-specific-machine-on-the-selected-dates","text":"","title":"22. Choose the machine name, start time, and end time, then click 'Download' to obtain data for that specific machine on the selected dates."},{"location":"ui.html#23-click-on-the-edit-button-to-modify-the-data","text":"","title":"23. Click on the 'Edit' button to modify the data."},{"location":"ui.html#24-click-update-to-save-the-edited-data-in-the-table","text":"","title":"24. Click 'Update' to save the edited data in the table."},{"location":"ui.html#25-utilize-the-delete-button-to-remove-specific-machine-data","text":"","title":"25. Utilize the 'Delete' button to remove specific machine data."},{"location":"ui.html#26-access-all-elements-of-the-table-data","text":"","title":"26. Access all elements of the table data."},{"location":"ui.html#27-select-add-element-type-to-introduce-a-new-element-type","text":"","title":"27. Select 'Add Element Type' to introduce a new element type."},{"location":"ui.html#28-enter-data-into-all-the-required-fields","text":"Click on the 'Create' button to generate a new element type.","title":"28. Enter data into all the required fields."},{"location":"ui.html#29-utilize-the-edit-button-to-modify-the-fields","text":"","title":"29. Utilize the 'Edit' button to modify the fields."},{"location":"ui.html#30-after-editing-the-updated-data-is-immediately-reflected-in-the-table","text":"","title":"30. After editing, the updated data is immediately reflected in the table."},{"location":"ui.html#31-click-on-the-delete-button-to-remove-specific-element-data","text":"","title":"31. Click on the 'Delete' button to remove specific element data."},{"location":"ui.html#32-select-add-welder-details-to-introduce-another-set-of-details","text":"","title":"32. Select 'Add Welder Details' to introduce another set of details."},{"location":"ui.html#33-enter-data-into-all-the-required-fields","text":"Click on the 'Create' button to generate new welder details.","title":"33. Enter data into all the required fields."},{"location":"ui.html#34-utilize-the-edit-button-to-modify-the-fields","text":"","title":"34. Utilize the 'Edit' button to modify the fields."},{"location":"ui.html#35-after-editing-the-updated-data-is-immediately-reflected-in-the-table","text":"","title":"35. After editing, the updated data is immediately reflected in the table."},{"location":"ui.html#36-click-on-the-delete-button-to-remove-specific-welder-details","text":"","title":"36. Click on the 'Delete' button to remove specific welder details."},{"location":"ui.html#37-select-add-project-details-to-introduce-another-set-of-project-details","text":"","title":"37. Select 'Add Project Details' to introduce another set of project details."},{"location":"ui.html#38-enter-data-into-all-the-required-fields","text":"Click on the 'Create' button to generate new project details.","title":"38. Enter data into all the required fields."},{"location":"ui.html#39-utilize-the-edit-button-to-modify-the-fields","text":"","title":"39. Utilize the 'Edit' button to modify the fields."},{"location":"ui.html#40-after-editing-the-updated-data-is-immediately-reflected-in-the-table","text":"","title":"40. After editing, the updated data is immediately reflected in the table."},{"location":"ui.html#41-click-on-the-delete-button-to-remove-specific-project-details","text":"","title":"41. Click on the 'Delete' button to remove specific project details."},{"location":"ui.html#42-navigate-to-the-report-menu-in-the-navbar-to-get-the-data-in-the-excel-format","text":"","title":"42. Navigate to the Report menu in the Navbar to get the data in the Excel Format"},{"location":"ui.html#43-now-you-can-enter-any-fields-and-click-on-submit-button","text":"","title":"43. now you can enter any fields and click on submit button"},{"location":"ui.html#44-to-filter-the-data-and-showing-in-the-table","text":"","title":"44. to filter the data and showing in the table"},{"location":"ui.html#45-click-on-download-excel-the-particulare-table-data-showing-will-displaying-excel-sheet","text":"","title":"45. click on download excel the particulare table data showing will displaying excel sheet"}]}